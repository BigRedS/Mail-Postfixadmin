NAME
    Mail::Postfixadmin - Interferes with a Postfix/MySQL virtual mailbox
    system

SYNOPSIS
    Mail::Postfixadmin is an attempt to provide a bunch of functions that
    wrap around the tedious SQL involved in interfering with a
    Postfix/Dovecot/MySQL virtual mailbox mail system.

    It's _very_much_ still in development. All sorts of things will change
    :) This is currently a todo list as much as it is documentation of the
    module.

    This is also completely not an object-orientated interface to the
    Postfix/Dovecot mailer, since it doesn't actually represent anything
    sensibly as objects. At best, it's an object-considering means of
    configuring it.

            use Mail::Postfixadmin;

            my $p = Mail::Postfixadmin->new();
            $p->createDomain(
                    domain        => 'example.org',
                    description   => 'an example',
                    num_mailboxes => '0',
            );

            $p->createUser(
                    ussername      => 'avi@example.com',
                    password_plain => 'password',
                    name           => 'avi',
            );

            my %dominfo = $p->getDomainInfo();

            my %userinfo = $p->getUserInfo();

            $p->changePassword('avi@example.com', 'complexpass');

CONSTRUCTOR AND STARTUP
  new()
    Creates and returns a new Mail::Postfixadmin object. You want to provide
    some way of determining how to connect to the database; there are three
    ways, listed in order of precedence (i.e. the third overrules the second
    which overrules the first):

    Firstly, you may pass nothing to the constructor, and have it parse
    /etc/postfix/main.cf:

      my $v = Mail::Postfixadmin->new();

    Secondly, you may pass `dbi', `dbuser' and `dbpass' which are
    essentially the three arguments to a `DBI->connect' (they are used for
    exactly this):

      my $v = Mail::Postfixadmin->new(
             dbi    => 'DBI:mysql:dbname',
             dbuser => 'username',
             dbpass => 'password'
      );

    Thirdly, you may pass a path to main.cf to the constructor, and have it
    parse that file to find a file specifying the file in which to find
    Postfix's MySQL configuration and then parse *that* file to get the
    credentials:

     my $v = Mail::Postfixadmin->new(
             maincf => '/etc/postfix/main.cf'
     );

    If `main.cf' is passed, the `dbi', `dbuser' and `dbpass' values are
    ignored and overwritten by data found in the files. `main.cf' is deemed
    to have been 'passed' if its value contains a forward-slash ('`/'').

    Password storage
    By default, passwords are crypted with Crypt::PasswdMD5 and stored in
    the `password' field of the relevant table. Optionally, you may also
    have them stored in cleartext and/or PGP-encrypted forms.

    To do this you need to set the `storeCleartextPassword' and/or
    `storeGPGPassword' keys to a non-zero value and make sure you have the
    correct fields in your DB; cleartext passwords need a `password_clear'
    field and GPG ones a `password_gpg' field in the `mailbox' table. GPG
    passwords also require an appropriately configured GPG keyring.

    GPG Passwords
    There's a number of other keys for GPG password storage:

      gpgSecretKey  The ID of the secret key.
      gpgRecipient  One of the ID fields of the public key.
      gpgBinary     Optional, path to the GPG binary. Defaults to /usr/bin/gpg
      gpgPassphrase Passphrase for the key(s).

    A complete example might read:

      my $v = Mail::Postfixadmin->new(
            storeGPGPassword => 1,
            gpgBinary     => '/usr/local/bin/gpg',
            gpgSecretKey  => '102FC956',
            gpgRecipient  => 'postfixadmin@avi.co',
            gpgPassphrase => 'Ue5gi2sei',
      );

    Each of these appear as attributes of the object with the same name so
    you can, for example, change the key used later on with:

      $p->gpgSecretKey("102FC958");

    );

METHODS
    getDomains()
    Returns an array of domains on the system. This is all domains for which
    the system will accept mail, including aliases.

    You can pass a pattern as the argument to get only domains matching that
    pattern:

      @domains = $getDomains('com$');

    getDomainsAndAliases()
    Returns a hash describing all domains on the system. Keys are domain
    names and values are the domain for which the key is an alias, where
    appropirate.

    As with getDomains, accepts a regex pattern as an argument.

      %domains = getDomainsAndAliases('org$');
      foreach(keys(%domains)){
            if($domains{$_} =~ /.+/){
                    print "$_ is an alias of $domains{$_}\n";
            }else{
                    print "$_ is a real domain" unless $domains{$_};
            }
      }

    getUsers()
    Returns a list of all users. If a domain is passed, only returns users
    on that domain.

    You can pass a pattern as the argument to get only users matchin that
    pattern.

      @users = getUsers('example.org');

    getUsersAndAliases()
    Returns a hash describing all users on the system. Keys are users and
    values are their targets.

    as with `getUsers', accepts a pattern to match.

      %users = getUsersAndAliases('example.org');
      foreach(keys(%users)){
            if($users{$_} =~ /.+/){
                    print "$_ is an alias of $users{$_}\n";
            }else{
                    print "$_ is a real mailbox" unless $users{$_};
            }
      }
    =cut

    sub getUsersAndAliases(){ my $self = shift; my $regex = shift; my @users
    = $self->getUsers($regex); # prepend a null string so that we definitely
    get a domain every odd- # numbered element of the list map returns, else
    the hash looks a bit # weird my %usersWithAliases = map {$_ =>
    "".$self->getAliasUserTarget($_)} @users; return %usersWithAliases; }

    getRealUsers()
    Returns a list of real users (i.e. those that are not aliases). If a
    domain is passed, returns only users on that domain, else returns a list
    of all real users on the system.

      @realUsers = getRealUsers('example.org');

    getAliasUsers()
    Returns a list of alias users on the system or, if a domain is passed as
    an argument, the domain.

      my @aliasUsers = $p->getAliasUsers('example.org');

    domainExists()
    Check for the existence of a domain. Returns the number found (in
    anticipation of also serving as a sort-of search) if the domain does
    exist, undef otherwise.

      if($p->$domainExists('example.org')){
            print "example.org exists!\n";
      }     

    userExists()
    Check for the existence of a user. Returns the number found (in
    anticipation of also serving as a sort-of search) if the user does
    exist, empty otherwise.

      if($p->userExists('user@example.com')){
            print "user@example.com exists!\n";
      }

    domainIsAlias()
    Returns true if the argument is a domain which is an alias (i.e. has a
    target).

    Actually returns the number of aliases the domain has.

      if($p->domainIsAlias('example.net'){
          print 'Mail for example.net is forwarded to ". getAliasDomainTarget('example.net');
      }

    getAliasDomainTarget()
    Returns the target of a domain if it's an alias, undef otherwise.

      if($p->domainIsAlias('example.net'){
          print 'Mail for example.net is forwarded to ". getAliasDomainTarget('example.net');
      }

    userIsAlias()
    Checks whether a user is an alias to another address.

      if($p->userIsAlias('user@example.net'){
          print 'Mail for user@example.net is forwarded to ". getAliasUserTarget('user@example.net');
      }

    getAliasUserTargets()
    Returns an array of addresses for which the current user is an alias.

     my @targets = $p->getAliasUserTargets($user);

      if($p->domainIsAlias('user@example.net'){
          print 'Mail for example.net is forwarded to ". join(", ", getAliasDomainTarget('user@example.net'));
      }

    getUserInfo()
    Returns a hash containing info about the user:

            username        Username. Should be an email address.
            password        The crypted password of the user
            name            The human name associated with the username
            domain          The domain the user is associated with
            local_part      The local part of the email address
            maildir         The path to the maildir *relative to the maildir root 
                            configured in Postfix/Dovecot*
            active          Whether or not the user is active
            created         Creation date
            modified        Last modified data

    Returns undef if the user doesn't exist.

    getDomainInfo()
    Returns a hash containing info about a domain. Keys:

            domain          The domain name
            description     Content of the description field
            quota           Mailbox size quota
            transport       Postfix transport (usually virtual)
            active          Whether the domain is active or not
            backupmx0       Whether this is a  backup MX for the domain
            mailboxes       Array of mailbox names associated with the domain 
                            (note: the full username, not just the local part)
            modified        last modified date 
            num_mailboxes   Count of the mailboxes (effectively, the length of the 
                            array in `mailboxes`)
            created         Creation data
            aliases         Alias quota for the domain
            maxquota        Mailbox quota for teh domain

    Returns undef if the domain doesn't exist.

  Passwords
    cryptPassword()
    This probably has no real use, except for where other functions use it.
    It should let you specify a salt for the password, but doesn't yet. It
    expects a cleartext password as an argument, and returns the crypted
    sort.

    cryptPasswordGPG()
    Encrypts a password with GPG. Only likely to work if storeGPGPasswords
    is set to a non-zero value but happy to try without it.

    cryptPasswordGPG()
    Decrypts a password with GPG. Only likely to work if storeGPGPasswords
    is set to a non-zero value but happy to try without it.

    changePassword()
    Changes the password of a user. Expects two arguments, a username and a
    new password:

            $p->changePassword("user@domain.com", "password");

    The salt is picked at pseudo-random; successive runs will (should)
    produce different results.

    changeCryptedPassword()
    changeCryptedPassword operates in exactly the same way as
    changePassword, but it expects to be passed an already-encrypted
    password, rather than a clear text one. It does no processing at all of
    its arguments, just writes it into the database.

  Creating things
    createDomain()
    Expects to be passed a hash of options, with the keys being the same as
    those output by `getDomainInfo()'. None are necessary except `domain'.

    Defaults are set as follows:

            domain          None; required.
            description     A null string
            quota           MySQL's default
            transport       'virtual'
            active          1 (active)
            backupmx0       MySQL's default
            modified        now
            created         now
            aliases         MySQL's default
            maxquota        MySQL's default

    Defaults are only set on keys that haven't been instantiated. If you set
    a key to the null string, it will not be set to the default - null will
    be passed to the DB and it may set its own default.

    On both success and failure the function will return a hash containing
    the options used to configure the domain - you can inspect this to see
    which defaults were used if you like.

    If the domain already exists, it will not alter it, instead it will
    return '2' rather than a hash.

    createUser()
    Expects to be passed a hash of options, with the keys being the same as
    those output by `getUserInfo()'. None are necessary except `username'.

    If both `password_plain' and <password_crypt> are in the passed hash,
    `password_crypt' will be used. If only password_plain is passed it will
    be crypted with `cryptPasswd()' and then inserted.

    Defaults are mostly sane where values aren't explicitly passed:

     username       required; no default
     password       null
     name           null
     maildir        username with a '/' appended to it
     quota          MySQL default (normally zero, which represents infinite)
     local_part     the part of the username to the left of the first '@'
     domain         the part of the username to the right of the last '@'
     created        now
     modified       now
     active         MySQL's default

    On success, returns a hash describing the user. You can inspect this to
    see which defaults were set if you like.

    This will not alter existing users. Instead, it returns '2' rather than
    a hash.

    createAliasDomain()
    Creates an alias domain:

     $p->createAliasDomain( 
            target => 'target.com',
            alias  => 'alias.com'
     );

    something@target.com. Notably, it does not check that the domain is not
    already aliased elsewhere, so you can end up aliasing one domain to two
    targets which is probably not what you want.

    You can pass three other keys in the hash, though only `target' and
    c<alias> are required: created 'created' date. Is passed verbatim to the
    db so should be in a format it understands. modified Ditto but for the
    modified date active The status of the domain. Again, passed verbatim to
    the db, but probably should be a '1' or a '0'.

    createAliasUser()
    Creates an alias user:

     $p->createAliasUser( 
            target => 'target@example.org');
            alias  => 'alias@example.net
     );

    will cause all mail sent to alias@example.com to be delivered to
    target@example.net.

    You may forward to more than one address by passing a comma-separated
    string:

     $p->createAliasDomain( 
            target => 'target@example.org, target@example.net',
            alias  => 'alias@example.net',
     );

    For some reason, the domain is stored separately in the db. If you pass
    a `domain' key in the hash, this is used. If not a regex is applied to
    the username ( `/\@(.+)$/' ). If that doesn't match, it Croaks.

    You may pass three other keys in the hash, though only `target' and
    `alias' are required:

     created   'created' date. Is passed verbatim to the db so should be in a format it understands.
     modified  Ditto but for the modified date
     active    The status of the domain. Again, passed verbatim to the db, but probably should be a '1' or a '0'.

    In full:

     $p->createAliasUser(
                    source   => 'someone@example.org',
                    target   => "target@example.org, target@example.net",
                    domain   => 'example.org',
    will cause all mail sent to something@alias.com to be delivered to 
                    modified => $p->now;
                    created  => $p->now;
                    active   => 1
     );

    On success a hash of the arguments is returned, with an addtional key:
    scalarTarget. This is the value of `target' as it was actually inserted
    into the DB. It will either be exactly the same as `target' if you've
    passed a scalar, or the array passed joined on a comma.

  Deleting things
    removeUser();
    Removes the passed user;

    Returns 1 on successful removal of a user, 2 if the user didn't exist to
    start with.

    `infostr' is set to the query run only if the user exists. If the user
    doesn't exist, no query is run and `infostr' is set to "user doesn't
    exist (<user>)";

    removeDomain()
    Removes the passed domain, and all of its attached users (using
    `removeUser()' on each).

    Returns 1 on successful removal of a user, 2 if the user didn't exist to
    start with.

    removeAliasDomain()
    Removes the alias property of a domain. An alias domain is just a normal
    domain which happens to be listed in a table matching it with a target.
    This simply removes that row out of that table; you probably want
    `removeDomain'.

    removeAliasUser()
    Removes the alias property of a user. An alias user is just a normal
    user which happens to be listed in a table matching it with a target.
    This simply removes that row out of that table; you probably want
    `removeUser'.

  Utilities
    getOptions
    Returns a hash of the options passed to the constructor plus whatever
    defaults were set, in the form that the constructor expects.

    getdbCredentials()
    Returns a hash of the db Credentials as expected by the constructor.
    Keys are `dbi' `dbuser' and `dbpass'. These are the three arguments for
    the DBI constructor; `dbi' is the full connection string (including
    `DBI:mysql' at the beginning.

    now()
    Returns the current time in a format suitable for passing straight to
    the database. Currently is just in MySQL datetime format (YYYY-MM-DD
    HH-MM-SS).

CLASS VARIABLES
    dbi
    `dbi' is the dbi object used by the rest of the module, having
    guessed/set the appropriate credentials. You can use it as you would the
    return directly from a $dbi->connect:

      my $sth = $p->{dbi}->prepare($query);
      $sth->execute;

    params
    `params' is the hash passed to the constructor, including any
    interpreting it does. If you've chosen to authenticate by passing the
    path to a main.cf file, for example, you can use the database
    credentials keys (`dbuser, dbpass and dbi') to initiate your own
    connection to the db (though you may as well use dbi, above).

    Other variables are likely to be put here as I decide I'd like to use
    them :)

DIAGNOSTICS
    Functions generally return:

    * null on failure
    * 1 on success
    * 2 where there was nothing to do (as if their job had already been
    performed)

    See `errstr' and `infostr' for better diagnostics.

  The DB schema
    Internally, the db schema is stored in two hashes.

    `%_tables' is a hash storing the names of the tables. The keys are the
    values used internally to refer to the tables, and the values are the
    names of the tables in the db.

    `%_fields' is a hash of hashes. The 'top' hash has as keys the internal
    names for the tables (as found in `getTables()'), with the values being
    hashes representing the tables. Here, the key is the name as used
    internally, and the value the names of those fields in the SQL.

    Currently, the assumptions made of the database schema are very small.
    We asssume four tables, 'mailbox', 'domain', 'alias' and 'alias domain':

     mysql> describe mailbox;
     +------------+--------------+------+-----+---------------------+-------+
     | Field      | Type         | Null | Key | Default             | Extra |
     +------------+--------------+------+-----+---------------------+-------+
     | username   | varchar(255) | NO   | PRI | NULL                |       |
     | password   | varchar(255) | NO   |     | NULL                |       |
     | name       | varchar(255) | NO   |     | NULL                |       |
     | maildir    | varchar(255) | NO   |     | NULL                |       |
     | quota      | bigint(20)   | NO   |     | 0                   |       |
     | local_part | varchar(255) | NO   |     | NULL                |       |
     | domain     | varchar(255) | NO   | MUL | NULL                |       |
     | created    | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | modified   | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | active     | tinyint(1)   | NO   |     | 1                   |       |
     +------------+--------------+------+-----+---------------------+-------+
     10 rows in set (0.00 sec)
   
     mysql> describe domain;
     +-------------+--------------+------+-----+---------------------+-------+
     | Field       | Type         | Null | Key | Default             | Extra |
     +-------------+--------------+------+-----+---------------------+-------+
     | domain      | varchar(255) | NO   | PRI | NULL                |       |
     | description | varchar(255) | NO   |     | NULL                |       |
     | aliases     | int(10)      | NO   |     | 0                   |       |
     | mailboxes   | int(10)      | NO   |     | 0                   |       |
     | maxquota    | bigint(20)   | NO   |     | 0                   |       |
     | quota       | bigint(20)   | NO   |     | 0                   |       |
     | transport   | varchar(255) | NO   |     | NULL                |       |
     | backupmx    | tinyint(1)   | NO   |     | 0                   |       |
     | created     | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | modified    | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | active      | tinyint(1)   | NO   |     | 1                   |       |
     +-------------+--------------+------+-----+---------------------+-------+
     11 rows in set (0.00 sec)

     mysql> describe alias_domain;
     +---------------+--------------+------+-----+---------------------+-------+
     | Field         | Type         | Null | Key | Default             | Extra |
     +---------------+--------------+------+-----+---------------------+-------+
     | alias_domain  | varchar(255) | NO   | PRI | NULL                |       |
     | target_domain | varchar(255) | NO   | MUL | NULL                |       |
     | created       | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | modified      | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | active        | tinyint(1)   | NO   | MUL | 1                   |       |
     +---------------+--------------+------+-----+---------------------+-------+
     5 rows in set (0.00 sec)

     mysql> describe alias;
     +----------+--------------+------+-----+---------------------+-------+
     | Field    | Type         | Null | Key | Default             | Extra |
     +----------+--------------+------+-----+---------------------+-------+
     | address  | varchar(255) | NO   | PRI | NULL                |       |
     | goto     | text         | NO   |     | NULL                |       |
     | domain   | varchar(255) | NO   | MUL | NULL                |       |
     | created  | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | modified | datetime     | NO   |     | 0000-00-00 00:00:00 |       |
     | active   | tinyint(1)   | NO   |     | 1                   |       |
     +----------+--------------+------+-----+---------------------+-------+
     6 rows in set (0.00 sec)

    And, er, that's it. If you wish to store cleartext passwords (by passing
    a value greater than 0 for 'storeCleartextPassword' to the constructor)
    you'll need a 'password_cleartext' column on the mailbox field.

    `getFields' returns `%_fields', `getTables %_tables'. `setFields' and
    `setTables' resets them to the hash passed as an argument. It does not
    merge the two hashes.

    This is the only way you should be interfering with those hashes.

    Since the module does no guesswork as to the db schema (yet), you might
    need to use these to get it to load yours. Even when it does do that, it
    might guess wrongly.

REQUIRES
    * Perl 5.10
    * Crypt::PasswdMD5
    * Carp
    * DBI

    Crypt::PasswdMD5 is `libcyrpt-passwdmd5-perl' in Debian, DBI is
    `libdbi-perl'

